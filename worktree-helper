#!/usr/bin/env bash
# worktree-helper - Sync gitignored files to git worktrees
set -euo pipefail

VERSION="0.1.0"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/worktree-helper"

# Colors (disable with NO_COLOR env var)
if [[ -z "${NO_COLOR:-}" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    RESET='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' BOLD='' RESET=''
fi

# -----------------------------------------------------------------------------
# Utility functions
# -----------------------------------------------------------------------------

log_info() { echo -e "${BLUE}info:${RESET} $*"; }
log_success() { echo -e "${GREEN}✓${RESET} $*"; }
log_warn() { echo -e "${YELLOW}warn:${RESET} $*"; }
log_error() { echo -e "${RED}error:${RESET} $*" >&2; }

die() { log_error "$@"; exit 1; }

require_cmd() {
    command -v "$1" &>/dev/null || die "Required command not found: $1"
}

require_jq() {
    require_cmd jq
}

# -----------------------------------------------------------------------------
# Git helpers
# -----------------------------------------------------------------------------

# Get the root of the current git repo
git_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Get the main worktree (first one listed, typically the original clone)
git_main_worktree() {
    git worktree list --porcelain | grep '^worktree ' | head -1 | cut -d' ' -f2
}

# Get all worktrees except the main one
git_secondary_worktrees() {
    git worktree list --porcelain | grep '^worktree ' | tail -n +2 | cut -d' ' -f2
}

# Get all worktrees
git_all_worktrees() {
    git worktree list --porcelain | grep '^worktree ' | cut -d' ' -f2
}

# Get remote URL
git_remote_url() {
    git remote get-url origin 2>/dev/null || echo ""
}

# -----------------------------------------------------------------------------
# Config helpers
# -----------------------------------------------------------------------------

# Get project config path
project_config_path() {
    local project="$1"
    echo "$CONFIG_DIR/projects/$project/config.json"
}

# Get project templates path
project_templates_path() {
    local project="$1"
    echo "$CONFIG_DIR/projects/$project/templates"
}

# Check if project exists
project_exists() {
    local project="$1"
    [[ -f "$(project_config_path "$project")" ]]
}

# Read a value from project config
project_config_get() {
    local project="$1"
    local key="$2"
    local config_file
    config_file="$(project_config_path "$project")"
    jq -r "$key // empty" "$config_file" 2>/dev/null
}

# Detect project from current directory
detect_project() {
    local search_path="${1:-$(pwd)}"
    local root remote_url root_name
    root="$(git -C "$search_path" rev-parse --show-toplevel 2>/dev/null)" || die "Not in a git repository: $search_path"
    remote_url="$(git -C "$search_path" remote get-url origin 2>/dev/null || echo "")"
    root_name="$(basename "$root")"

    # Check each project config for a match
    for config_file in "$CONFIG_DIR/projects"/*/config.json; do
        [[ -f "$config_file" ]] || continue
        local project_name
        project_name="$(jq -r '.project.name' "$config_file")"

        # Check remote patterns
        local patterns
        patterns="$(jq -r '.project.match.remote_patterns[]? // empty' "$config_file" 2>/dev/null)"
        while IFS= read -r pattern; do
            [[ -z "$pattern" ]] && continue
            if [[ "$remote_url" =~ $pattern ]]; then
                echo "$project_name"
                return 0
            fi
        done <<< "$patterns"

        # Check root name
        local match_root
        match_root="$(jq -r '.project.match.root_name // empty' "$config_file" 2>/dev/null)"
        if [[ -n "$match_root" && "$root_name" == "$match_root" ]]; then
            echo "$project_name"
            return 0
        fi
    done

    # Fallback: use root directory name
    echo "$root_name"
}

# -----------------------------------------------------------------------------
# Commands
# -----------------------------------------------------------------------------

cmd_help() {
    cat <<EOF
${BOLD}worktree-helper${RESET} v$VERSION - Sync gitignored files to git worktrees

${BOLD}USAGE:${RESET}
    worktree-helper <command> [options]

${BOLD}COMMANDS:${RESET}
    init <project>          Initialize config for a project (auto-detects main worktree)
    sync [worktree-path]    Sync files to worktree(s)
    status                  Show sync status for all worktrees
    show-templates          Show captured template files (optionally with contents)
    add-file <path>         Add explicit file to sync config
    add-files <glob>        Add glob pattern (e.g., **/CLAUDE.local.md)
    capture-templates       Copy files from main repo to templates dir
    install-alias           Add git aliases to ~/.gitconfig
    list                    List configured projects
    help                    Show this help message
    version                 Show version

${BOLD}OPTIONS:${RESET}
    --project <name>        Specify project (default: auto-detect)
    --source <path>         Specify source path for init (default: auto-detect)
    --all                   Sync to all worktrees
    --force                 Overwrite without prompting
    --dry-run               Show what would be done without doing it

${BOLD}EXAMPLES:${RESET}
    # Initial setup
    worktree-helper init all
    worktree-helper add-file justfile
    worktree-helper add-files "**/CLAUDE.local.md"
    worktree-helper capture-templates

    # Sync to new worktree
    git wt-add ../feature-branch feature-branch

    # Sync to existing worktrees
    worktree-helper sync --all
EOF
}

cmd_version() {
    echo "worktree-helper v$VERSION"
}

cmd_init() {
    local project="" source_path=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper init <project> [options]

Initialize a new project configuration.

Options:
  --source <path>   Source repository path (default: auto-detect main worktree)
  --help, -h        Show this help message

Examples:
  worktree-helper init myproject
  worktree-helper init myproject --source /path/to/repo
EOF
                return 0 ;;
            --source) source_path="$2"; shift 2 ;;
            --source=*) source_path="${1#*=}"; shift ;;
            -*) die "Unknown option: $1" ;;
            *)
                if [[ -z "$project" ]]; then
                    project="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift ;;
        esac
    done

    [[ -n "$project" ]] || die "Project name required. Usage: worktree-helper init <project>"

    # Auto-detect source path if not provided
    if [[ -z "$source_path" ]]; then
        source_path="$(git_main_worktree)" || die "Could not detect main worktree. Use --source to specify."
        log_info "Auto-detected main worktree: $source_path"
    fi

    [[ -d "$source_path" ]] || die "Source path does not exist: $source_path"

    local config_file templates_dir
    config_file="$(project_config_path "$project")"
    templates_dir="$(project_templates_path "$project")"

    if [[ -f "$config_file" ]]; then
        log_warn "Project '$project' already exists at $config_file"
        read -rp "Overwrite? [y/N] " choice
        [[ "$choice" =~ ^[Yy]$ ]] || { log_info "Aborted."; return 0; }
    fi

    # Create directories
    mkdir -p "$(dirname "$config_file")" "$templates_dir"

    # Detect remote URL for match patterns
    local remote_url root_name
    remote_url="$(cd "$source_path" && git_remote_url)"
    root_name="$(basename "$source_path")"

    # Create config with sensible default excludes
    cat > "$config_file" <<EOF
{
  "project": {
    "name": "$project",
    "source_path": "$source_path",
    "match": {
      "remote_patterns": [],
      "root_name": "$root_name"
    }
  },
  "files": [],
  "patterns": [],
  "excludes": [
    ".git",
    "dist-newstyle",
    "node_modules",
    ".stack-work",
    ".cabal",
    "target",
    "build",
    ".cache",
    "__pycache__",
    ".venv",
    "venv"
  ]
}
EOF

    log_success "Created project config: $config_file"
    log_info "Templates directory: $templates_dir"
    log_info ""
    log_info "Next steps:"
    log_info "  1. Add files:     worktree-helper add-file justfile --project $project"
    log_info "  2. Add patterns:  worktree-helper add-files \"**/CLAUDE.local.md\" --project $project"
    log_info "  3. Capture:       worktree-helper capture-templates --project $project"
}

cmd_add_file() {
    require_jq
    local file_path="" project=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper add-file <path> [options]

Add an explicit file path to sync.

Options:
  --project <name>  Project name (default: auto-detect)
  --help, -h        Show this help message

Examples:
  worktree-helper add-file justfile
  worktree-helper add-file .claude/settings.local.json --project myproject
EOF
                return 0 ;;
            --project) project="$2"; shift 2 ;;
            --project=*) project="${1#*=}"; shift ;;
            -*) die "Unknown option: $1" ;;
            *)
                if [[ -z "$file_path" ]]; then
                    file_path="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift ;;
        esac
    done

    [[ -n "$file_path" ]] || die "File path required. Usage: worktree-helper add-file <path>"

    # Auto-detect project if not provided
    if [[ -z "$project" ]]; then
        project="$(detect_project)"
        log_info "Auto-detected project: $project"
    fi

    project_exists "$project" || die "Project '$project' not found. Run: worktree-helper init $project"

    local config_file
    config_file="$(project_config_path "$project")"

    # Check if file already exists in config
    if jq -e ".files[] | select(.path == \"$file_path\")" "$config_file" &>/dev/null; then
        log_warn "File '$file_path' already in config"
        return 0
    fi

    # Add file to config
    local tmp_file
    tmp_file="$(mktemp)"
    jq ".files += [{\"path\": \"$file_path\"}]" "$config_file" > "$tmp_file"
    mv "$tmp_file" "$config_file"

    log_success "Added file: $file_path"
}

cmd_add_files() {
    require_jq
    local glob_pattern="" project=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper add-files <glob> [options]

Add a glob pattern to sync (e.g., **/CLAUDE.local.md).
Remember to quote the pattern to prevent shell expansion.

Options:
  --project <name>  Project name (default: auto-detect)
  --help, -h        Show this help message

Examples:
  worktree-helper add-files "**/CLAUDE.local.md"
  worktree-helper add-files "**/.envrc" --project myproject
EOF
                return 0 ;;
            --project) project="$2"; shift 2 ;;
            --project=*) project="${1#*=}"; shift ;;
            -*) die "Unknown option: $1" ;;
            *)
                if [[ -z "$glob_pattern" ]]; then
                    glob_pattern="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift ;;
        esac
    done

    [[ -n "$glob_pattern" ]] || die "Glob pattern required. Usage: worktree-helper add-files <glob>"

    # Auto-detect project if not provided
    if [[ -z "$project" ]]; then
        project="$(detect_project)"
        log_info "Auto-detected project: $project"
    fi

    project_exists "$project" || die "Project '$project' not found. Run: worktree-helper init $project"

    local config_file
    config_file="$(project_config_path "$project")"

    # Check if pattern already exists in config
    if jq -e ".patterns[] | select(.glob == \"$glob_pattern\")" "$config_file" &>/dev/null; then
        log_warn "Pattern '$glob_pattern' already in config"
        return 0
    fi

    # Add pattern to config
    local tmp_file
    tmp_file="$(mktemp)"
    jq ".patterns += [{\"glob\": \"$glob_pattern\"}]" "$config_file" > "$tmp_file"
    mv "$tmp_file" "$config_file"

    log_success "Added pattern: $glob_pattern"
}

cmd_capture_templates() {
    require_jq
    local project="" dry_run=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper capture-templates [options]

Copy files from source repo to templates directory.
Files are determined by the 'files' and 'patterns' in the project config.

Options:
  --project <name>  Project name (default: auto-detect)
  --dry-run         Show what would be copied without copying
  --help, -h        Show this help message

Examples:
  worktree-helper capture-templates
  worktree-helper capture-templates --dry-run
  worktree-helper capture-templates --project myproject
EOF
                return 0 ;;
            --project) project="$2"; shift 2 ;;
            --project=*) project="${1#*=}"; shift ;;
            --dry-run) dry_run=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unexpected argument: $1" ;;
        esac
    done

    # Auto-detect project if not provided
    if [[ -z "$project" ]]; then
        project="$(detect_project)"
        log_info "Auto-detected project: $project"
    fi

    project_exists "$project" || die "Project '$project' not found. Run: worktree-helper init $project"

    local config_file source_path templates_dir
    config_file="$(project_config_path "$project")"
    source_path="$(project_config_get "$project" '.project.source_path')"
    templates_dir="$(project_templates_path "$project")"

    [[ -d "$source_path" ]] || die "Source path does not exist: $source_path"

    # Build exclude list from config
    local -a excludes=()
    while IFS= read -r exclude; do
        [[ -n "$exclude" ]] && excludes+=("$exclude")
    done < <(jq -r '.excludes[]? // empty' "$config_file")

    # Function to check if path should be excluded
    is_excluded() {
        local path="$1"
        for exclude in "${excludes[@]}"; do
            if [[ "$path" == *"/$exclude/"* || "$path" == "$exclude/"* || "$path" == *"/$exclude" ]]; then
                return 0
            fi
        done
        return 1
    }

    local count=0

    # Process explicit files
    while IFS= read -r file_path; do
        [[ -z "$file_path" ]] && continue
        local src="$source_path/$file_path"
        local dst="$templates_dir/$file_path"

        if [[ ! -f "$src" ]]; then
            log_warn "File not found: $src"
            continue
        fi

        if $dry_run; then
            log_info "[dry-run] Would copy: $src → $dst"
        else
            mkdir -p "$(dirname "$dst")"
            cp "$src" "$dst"
            log_success "Copied: $file_path"
        fi
        ((count++)) || true || true
    done < <(jq -r '.files[].path // empty' "$config_file")

    # Process glob patterns
    while IFS= read -r glob_pattern; do
        [[ -z "$glob_pattern" ]] && continue

        # Use bash globstar to find matching files (process substitution to avoid subshell)
        while IFS= read -r rel_path; do
            [[ -z "$rel_path" ]] && continue

            # Check excludes
            if is_excluded "$rel_path"; then
                continue
            fi

            local src="$source_path/$rel_path"
            local dst="$templates_dir/$rel_path"

            if $dry_run; then
                log_info "[dry-run] Would copy: $src → $dst"
            else
                mkdir -p "$(dirname "$dst")"
                cp "$src" "$dst"
                log_success "Copied: $rel_path"
            fi
            ((count++)) || true
        done < <(cd "$source_path" && shopt -s globstar nullglob && for f in $glob_pattern; do [[ -f "$f" ]] && echo "$f"; done)
    done < <(jq -r '.patterns[].glob // empty' "$config_file")

    if $dry_run; then
        log_info "[dry-run] Would capture $count file(s)"
    else
        log_info "Captured $count file(s) to $templates_dir"
    fi
}

cmd_show_templates() {
    require_jq
    local project="" show_contents=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper show-templates [options]

Show captured template files, optionally with their contents.

Options:
  --project <name>  Project name (default: auto-detect)
  --contents        Show file contents
  --help, -h        Show this help message

Examples:
  worktree-helper show-templates
  worktree-helper show-templates --contents
  worktree-helper show-templates --project myproject
EOF
                return 0 ;;
            --project) project="$2"; shift 2 ;;
            --project=*) project="${1#*=}"; shift ;;
            --contents) show_contents=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unexpected argument: $1" ;;
        esac
    done

    # Auto-detect project if not provided
    if [[ -z "$project" ]]; then
        project="$(detect_project)"
        log_info "Auto-detected project: $project"
    fi

    project_exists "$project" || die "Project '$project' not found. Run: worktree-helper init $project"

    local templates_dir
    templates_dir="$(project_templates_path "$project")"

    if [[ ! -d "$templates_dir" ]]; then
        log_warn "No templates directory found: $templates_dir"
        log_info "Run 'worktree-helper capture-templates' to capture files."
        return 0
    fi

    local count=0
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        local rel_path="${file#$templates_dir/}"
        ((count++)) || true

        if $show_contents; then
            echo -e "${BOLD}━━━ $rel_path ━━━${RESET}"
            cat "$file"
            echo ""
        else
            echo "  $rel_path"
        fi
    done < <(find "$templates_dir" -type f | sort)

    if [[ $count -eq 0 ]]; then
        log_info "No template files captured yet."
        log_info "Run 'worktree-helper capture-templates' to capture files."
    elif ! $show_contents; then
        echo ""
        log_info "$count template file(s) in $templates_dir"
    fi
}

cmd_sync() {
    require_jq
    local target_path="" project="" sync_all=false force=false dry_run=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper sync [worktree-path] [options]

Sync template files to worktree(s).

Options:
  --project <name>  Project name (default: auto-detect)
  --all             Sync to all worktrees
  --force           Overwrite without prompting
  --dry-run         Show what would be synced without syncing
  --help, -h        Show this help message

Examples:
  worktree-helper sync
  worktree-helper sync --all
  worktree-helper sync /path/to/worktree
  worktree-helper sync --all --force
EOF
                return 0 ;;
            --project) project="$2"; shift 2 ;;
            --project=*) project="${1#*=}"; shift ;;
            --all) sync_all=true; shift ;;
            --force) force=true; shift ;;
            --dry-run) dry_run=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *)
                if [[ -z "$target_path" ]]; then
                    target_path="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift ;;
        esac
    done

    # Determine target worktrees first (needed for project detection)
    local -a targets=()
    if $sync_all; then
        while IFS= read -r wt; do
            targets+=("$wt")
        done < <(git_all_worktrees)
    elif [[ -n "$target_path" ]]; then
        targets+=("$target_path")
    else
        targets+=("$(git_root)")
    fi

    # Auto-detect project if not provided (use first target for detection)
    if [[ -z "$project" ]]; then
        project="$(detect_project "${targets[0]}")"
        log_info "Auto-detected project: $project"
    fi

    project_exists "$project" || die "Project '$project' not found. Run: worktree-helper init $project"

    local templates_dir
    templates_dir="$(project_templates_path "$project")"

    [[ -d "$templates_dir" ]] || die "Templates directory does not exist: $templates_dir (run capture-templates first)"

    local overwrite_all=false skip_all=false

    for target in "${targets[@]}"; do
        log_info "Syncing to ${BOLD}$target${RESET}..."

        # Sync all files from templates directory
        while IFS= read -r src_file; do
            [[ -z "$src_file" ]] && continue
            local rel_path="${src_file#$templates_dir/}"
            local dst_file="$target/$rel_path"

            if [[ -f "$dst_file" ]]; then
                # File exists - check if different
                if cmp -s "$src_file" "$dst_file"; then
                    echo -e "  ${BLUE}[same]${RESET} $rel_path"
                    continue
                fi

                if $dry_run; then
                    echo -e "  ${YELLOW}[dry-run]${RESET} Would overwrite: $rel_path"
                elif $force || $overwrite_all; then
                    cp "$src_file" "$dst_file"
                    echo -e "  ${YELLOW}[overwritten]${RESET} $rel_path"
                elif $skip_all; then
                    echo -e "  ${BLUE}[skipped]${RESET} $rel_path"
                else
                    # Interactive prompt (read from /dev/tty since stdin is used by the loop)
                    echo -e "  ${YELLOW}[conflict]${RESET} $rel_path"
                    local choice=""
                    while true; do
                        if ! choice=$(bash -c 'read -rp "    [o]verwrite | [s]kip | [d]iff | [b]ackup+overwrite | [O]verwrite all | [S]kip all: " c </dev/tty && echo "$c"' 2>/dev/null); then
                            # No TTY available, skip by default
                            echo "    Skipped (no TTY for interactive prompt, use --force to overwrite)"
                            break
                        fi
                        case "$choice" in
                            o)
                                if $dry_run; then
                                    echo "    [dry-run] Would overwrite"
                                else
                                    cp "$src_file" "$dst_file"
                                    echo "    Overwritten"
                                fi
                                break ;;
                            s)
                                echo "    Skipped"
                                break ;;
                            d)
                                diff --color=auto "$dst_file" "$src_file" || true
                                ;;
                            b)
                                if $dry_run; then
                                    echo "    [dry-run] Would backup and overwrite"
                                else
                                    cp "$dst_file" "$dst_file.backup"
                                    cp "$src_file" "$dst_file"
                                    echo "    Backed up to $rel_path.backup and overwritten"
                                fi
                                break ;;
                            O)
                                overwrite_all=true
                                if $dry_run; then
                                    echo "    [dry-run] Would overwrite"
                                else
                                    cp "$src_file" "$dst_file"
                                    echo "    Overwritten"
                                fi
                                break ;;
                            S)
                                skip_all=true
                                echo "    Skipped"
                                break ;;
                            *)
                                echo "    Invalid choice" ;;
                        esac
                    done
                fi
            else
                # New file
                if $dry_run; then
                    echo -e "  ${GREEN}[dry-run]${RESET} Would create: $rel_path"
                else
                    mkdir -p "$(dirname "$dst_file")"
                    cp "$src_file" "$dst_file"
                    echo -e "  ${GREEN}[new]${RESET} $rel_path"
                fi
            fi
        done < <(find "$templates_dir" -type f)
    done

    log_success "Sync complete"
}

cmd_status() {
    require_jq
    local project=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper status [options]

Show sync status for all worktrees.

Options:
  --project <name>  Project name (default: auto-detect)
  --help, -h        Show this help message

Examples:
  worktree-helper status
  worktree-helper status --project myproject
EOF
                return 0 ;;
            --project) project="$2"; shift 2 ;;
            --project=*) project="${1#*=}"; shift ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unexpected argument: $1" ;;
        esac
    done

    # Auto-detect project if not provided
    if [[ -z "$project" ]]; then
        project="$(detect_project)"
    fi

    project_exists "$project" || die "Project '$project' not found. Run: worktree-helper init $project"

    local templates_dir source_path
    templates_dir="$(project_templates_path "$project")"
    source_path="$(project_config_get "$project" '.project.source_path')"

    echo -e "${BOLD}Project:${RESET} $project"
    echo -e "${BOLD}Source:${RESET} $source_path"
    echo -e "${BOLD}Templates:${RESET} $templates_dir"
    echo ""

    # Count template files
    local template_count=0
    if [[ -d "$templates_dir" ]]; then
        template_count=$(find "$templates_dir" -type f | wc -l)
    fi
    echo -e "${BOLD}Template files:${RESET} $template_count"

    if [[ $template_count -gt 0 ]]; then
        echo ""
        find "$templates_dir" -type f | while read -r f; do
            echo "  - ${f#$templates_dir/}"
        done
    fi

    echo ""
    echo -e "${BOLD}Worktrees:${RESET}"

    while IFS= read -r worktree; do
        [[ -z "$worktree" ]] && continue
        echo -e "  ${BOLD}$worktree${RESET}"

        # Check each template file
        find "$templates_dir" -type f 2>/dev/null | while read -r src_file; do
            local rel_path="${src_file#$templates_dir/}"
            local dst_file="$worktree/$rel_path"

            if [[ ! -f "$dst_file" ]]; then
                echo -e "    ${RED}[missing]${RESET} $rel_path"
            elif cmp -s "$src_file" "$dst_file"; then
                echo -e "    ${GREEN}[synced]${RESET} $rel_path"
            else
                echo -e "    ${YELLOW}[differs]${RESET} $rel_path"
            fi
        done
    done < <(git_all_worktrees)
}

cmd_list() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper list

List all configured projects.

Options:
  --help, -h  Show this help message
EOF
                return 0 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unexpected argument: $1" ;;
        esac
    done

    echo -e "${BOLD}Configured projects:${RESET}"

    local found=false
    for config_file in "$CONFIG_DIR/projects"/*/config.json; do
        [[ -f "$config_file" ]] || continue
        found=true
        local name source_path
        name="$(jq -r '.project.name' "$config_file")"
        source_path="$(jq -r '.project.source_path' "$config_file")"
        echo -e "  ${BOLD}$name${RESET}"
        echo "    Source: $source_path"
        echo "    Config: $config_file"
    done

    if ! $found; then
        echo "  (none)"
        echo ""
        echo "Run 'worktree-helper init <project>' to create a project."
    fi
}

cmd_install_alias() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                cat <<EOF
Usage: worktree-helper install-alias

Add 'git wt-add' alias to ~/.gitconfig for automatic sync on worktree creation.

Options:
  --help, -h  Show this help message

The alias wraps 'git worktree add' and automatically runs 'worktree-helper sync'
on the new worktree.

Usage after install:
  git wt-add <path> <branch>
  git wt-add --checkout ~/worktrees/feature feature-branch
EOF
                return 0 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unexpected argument: $1" ;;
        esac
    done

    local gitconfig="$HOME/.gitconfig"

    # Check if alias already exists
    if git config --global --get alias.wt-add &>/dev/null; then
        log_warn "Git alias 'wt-add' already exists"
        local current
        current="$(git config --global --get alias.wt-add)"
        echo "  Current: $current"
        read -rp "Overwrite? [y/N] " choice
        [[ "$choice" =~ ^[Yy]$ ]] || { log_info "Aborted."; return 0; }
    fi

    # Add alias
    # Find the path argument (first non-flag argument) from git worktree add args
    git config --global alias.wt-add '!f() { git worktree add "$@"; local path=""; for arg in "$@"; do case "$arg" in -*) ;; *) path="$arg"; break;; esac; done; worktree-helper sync "$(realpath "$path")"; }; f'

    log_success "Added git alias 'wt-add'"
    log_info "Usage: git wt-add <path> <branch>"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        init) cmd_init "$@" ;;
        sync) cmd_sync "$@" ;;
        status) cmd_status "$@" ;;
        add-file) cmd_add_file "$@" ;;
        add-files) cmd_add_files "$@" ;;
        capture-templates) cmd_capture_templates "$@" ;;
        show-templates) cmd_show_templates "$@" ;;
        install-alias) cmd_install_alias "$@" ;;
        list) cmd_list "$@" ;;
        help|--help|-h) cmd_help ;;
        version|--version|-v) cmd_version ;;
        *) die "Unknown command: $cmd. Run 'worktree-helper help' for usage." ;;
    esac
}

main "$@"
